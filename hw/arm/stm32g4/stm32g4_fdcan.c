/* stm32g4_fdcan.c */

#include "qemu/osdep.h"
#include "hw/irq.h"
#include "hw/qdev-properties.h"
#include "include/hw/arm/stm32g4/stm32g4_fdcan.h"
#include "migration/vmstate.h"

#define STM32G4_FDCAN_MMIO TYPE_STM32G4_FDCAN "_mmio"
#define STM32G4_FDCAN_MMIO_SIZE 0x104

static uint64_t stm32g4_fdcan_mmio_read(void *opaque, hwaddr offset,
                                        unsigned size)
{
    STM32G4FDCANState *s = STM32G4_FDCAN(opaque);
    uint64_t ret = 0;

    switch (offset) {
    case 0x000 ... 0x003:
        /* CREL, FDCAN Core Release Register */
        ret = s->crel;
        break;

    case 0x004 ... 0x007:
        /* ENDN, FDCAN Core Release Register */
        ret = s->endn;
        break;

    case 0x00C ... 0x00F:
        /* DBTP, This register is only writable if bits CCCR.CCE and CCCR.INIT
            are set. The CAN bit time may be programed in the range of 4 to 25
            time quanta. The CAN time quantum may be programmed in the range of
            1 to 1024 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock period.
            DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2.
            Therefore the length of the bit time is (programmed values) [DTSEG1
            + DTSEG2 + 3] tq or (functional values) [Sync_Seg + Prop_Seg +
            Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT)
            is zero, meaning the data for the next bit is available at the first
            clock edge after the sample point. */
        ret = s->dbtp;
        break;

    case 0x010 ... 0x013:
        /* TEST, Write access to the Test Register has to be enabled by setting
            bit CCCR[TEST] to 1 . All Test Register functions are set to their
            reset values when bit CCCR[TEST] is reset. Loop Back mode and
            software control of Tx pin FDCANx_TX are hardware test modes.
            Programming TX differently from 00 may disturb the message transfer
            on the CAN bus. */
        ret = s->test;
        break;

    case 0x014 ... 0x017:
        /* RWD, The RAM Watchdog monitors the READY output of the Message RAM. A
            Message RAM access starts the Message RAM Watchdog Counter with the
            value configured by the RWD[WDC] bits. The counter is reloaded with
            RWD[WDC] bits when the Message RAM signals successful completion by
            activating its READY output. In case there is no response from the
            Message RAM until the counter has counted down to 0, the counter
            stops and interrupt flag IR[WDI] bit is set. The RAM Watchdog
            Counter is clocked by the fdcan_pclk clock. */
        ret = s->rwd;
        break;

    case 0x018 ... 0x01B:
        /* CCCR, For details about setting and resetting of single bits see
            Software initialization. */
        ret = s->cccr;
        break;

    case 0x01C ... 0x01F:
        /* NBTP, FDCAN_NBTP */
        ret = s->nbtp;
        break;

    case 0x020 ... 0x023:
        /* TSCC, FDCAN Timestamp Counter Configuration Register */
        ret = s->tscc;
        break;

    case 0x024 ... 0x027:
        /* TSCV, FDCAN Timestamp Counter Value Register */
        ret = s->tscv;
        break;

    case 0x028 ... 0x02B:
        /* TOCC, FDCAN Timeout Counter Configuration Register */
        ret = s->tocc;
        break;

    case 0x02C ... 0x02F:
        /* TOCV, FDCAN Timeout Counter Value Register */
        ret = s->tocv;
        break;

    case 0x040 ... 0x043:
        /* ECR, FDCAN Error Counter Register */
        ret = s->ecr;
        break;

    case 0x044 ... 0x047:
        /* PSR, FDCAN Protocol Status Register */
        ret = s->psr;
        break;

    case 0x048 ... 0x04B:
        /* TDCR, FDCAN Transmitter Delay Compensation Register */
        ret = s->tdcr;
        break;

    case 0x050 ... 0x053:
        /* IR, The flags are set when one of the listed conditions is detected
            (edge-sensitive). The flags remain set until the Host clears them. A
            flag is cleared by writing a 1 to the corresponding bit position.
            Writing a 0 has no effect. A hard reset will clear the register. The
            configuration of IE controls whether an interrupt is generated. The
            configuration of ILS controls on which interrupt line an interrupt
            is signaled. */
        ret = s->ir;
        break;

    case 0x054 ... 0x057:
        /* IE, The settings in the Interrupt Enable register determine which
            status changes in the Interrupt Register will be signaled on an
            interrupt line. */
        ret = s->ie;
        break;

    case 0x058 ... 0x05B:
        /* ILS, The Interrupt Line Select register assigns an interrupt
            generated by a specific interrupt flag from the Interrupt Register
            to one of the two module interrupt lines. For interrupt generation
            the respective interrupt line has to be enabled via ILE[EINT0] and
            ILE[EINT1]. */
        ret = s->ils;
        break;

    case 0x05C ... 0x05F:
        /* ILE, Each of the two interrupt lines to the CPU can be
            enabled/disabled separately by programming bits EINT0 and EINT1. */
        ret = s->ile;
        break;

    case 0x080 ... 0x083:
        /* RXGFC, Global settings for Message ID filtering. The Global Filter
            Configuration controls the filter path for standard and extended
            messages as described in Figure706: Standard Message ID filter path
            and Figure707: Extended Message ID filter path. */
        ret = s->rxgfc;
        break;

    case 0x084 ... 0x087:
        /* XIDAM, FDCAN Extended ID and Mask Register */
        ret = s->xidam;
        break;

    case 0x088 ... 0x08B:
        /* HPMS, This register is updated every time a Message ID filter element
            configured to generate a priority event match. This can be used to
            monitor the status of incoming high priority messages and to enable
            fast access to these messages. */
        ret = s->hpms;
        break;

    case 0x090 ... 0x093:
        /* RXF0S, FDCAN Rx FIFO 0 Status Register */
        ret = s->rxf0s;
        break;

    case 0x094 ... 0x097:
        /* RXF0A, CAN Rx FIFO 0 Acknowledge Register */
        ret = s->rxf0a;
        break;

    case 0x098 ... 0x09B:
        /* RXF1S, FDCAN Rx FIFO 1 Status Register */
        ret = s->rxf1s;
        break;

    case 0x09C ... 0x09F:
        /* RXF1A, FDCAN Rx FIFO 1 Acknowledge Register */
        ret = s->rxf1a;
        break;

    case 0x0C0 ... 0x0C3:
        /* TXBC, FDCAN Tx Buffer Configuration Register */
        ret = s->txbc;
        break;

    case 0x0C4 ... 0x0C7:
        /* TXFQS, The Tx FIFO/Queue status is related to the pending Tx requests
            listed in register TXBRP. Therefore the effect of Add/Cancellation
            requests may be delayed due to a running Tx scan (TXBRP not yet
            updated). */
        ret = s->txfqs;
        break;

    case 0x0C8 ... 0x0CB:
        /* TXBRP, FDCAN Tx Buffer Request Pending Register */
        ret = s->txbrp;
        break;

    case 0x0CC ... 0x0CF:
        /* TXBAR, FDCAN Tx Buffer Add Request Register */
        ret = s->txbar;
        break;

    case 0x0D0 ... 0x0D3:
        /* TXBCR, FDCAN Tx Buffer Cancellation Request Register */
        ret = s->txbcr;
        break;

    case 0x0D4 ... 0x0D7:
        /* TXBTO, FDCAN Tx Buffer Transmission Occurred Register */
        ret = s->txbto;
        break;

    case 0x0D8 ... 0x0DB:
        /* TXBCF, FDCAN Tx Buffer Cancellation Finished Register */
        ret = s->txbcf;
        break;

    case 0x0DC ... 0x0DF:
        /* TXBTIE, FDCAN Tx Buffer Transmission Interrupt Enable Register */
        ret = s->txbtie;
        break;

    case 0x0E0 ... 0x0E3:
        /* TXBCIE, FDCAN Tx Buffer Cancellation Finished Interrupt Enable
            Register */
        ret = s->txbcie;
        break;

    case 0x0E4 ... 0x0E7:
        /* TXEFS, FDCAN Tx Event FIFO Status Register */
        ret = s->txefs;
        break;

    case 0x0E8 ... 0x0EB:
        /* TXEFA, FDCAN Tx Event FIFO Acknowledge Register */
        ret = s->txefa;
        break;

    case 0x100 ... 0x103:
        /* CKDIV, FDCAN CFG clock divider register */
        ret = s->ckdiv;
        break;

    default:
        printf("%s: unimplemented read from 0x%" HWADDR_PRIx ", size %d\n",
               __func__, offset, size);
        break;
    }

    return ret;
}

static void stm32g4_fdcan_mmio_write(void *opaque, hwaddr offset,
                                     uint64_t value, unsigned size)
{
    STM32G4FDCANState *s = STM32G4_FDCAN(opaque);

    switch (offset) {
    case 0x000 ... 0x003:
        /* CREL, FDCAN Core Release Register */
        s->crel = value;
        break;

    case 0x004 ... 0x007:
        /* ENDN, FDCAN Core Release Register */
        s->endn = value;
        break;

    case 0x00C ... 0x00F:
        /* DBTP, This register is only writable if bits CCCR.CCE and CCCR.INIT
            are set. The CAN bit time may be programed in the range of 4 to 25
            time quanta. The CAN time quantum may be programmed in the range of
            1 to 1024 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock period.
            DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2.
            Therefore the length of the bit time is (programmed values) [DTSEG1
            + DTSEG2 + 3] tq or (functional values) [Sync_Seg + Prop_Seg +
            Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT)
            is zero, meaning the data for the next bit is available at the first
            clock edge after the sample point. */
        s->dbtp = value;
        break;

    case 0x010 ... 0x013:
        /* TEST, Write access to the Test Register has to be enabled by setting
            bit CCCR[TEST] to 1 . All Test Register functions are set to their
            reset values when bit CCCR[TEST] is reset. Loop Back mode and
            software control of Tx pin FDCANx_TX are hardware test modes.
            Programming TX differently from 00 may disturb the message transfer
            on the CAN bus. */
        s->test = value;
        break;

    case 0x014 ... 0x017:
        /* RWD, The RAM Watchdog monitors the READY output of the Message RAM. A
            Message RAM access starts the Message RAM Watchdog Counter with the
            value configured by the RWD[WDC] bits. The counter is reloaded with
            RWD[WDC] bits when the Message RAM signals successful completion by
            activating its READY output. In case there is no response from the
            Message RAM until the counter has counted down to 0, the counter
            stops and interrupt flag IR[WDI] bit is set. The RAM Watchdog
            Counter is clocked by the fdcan_pclk clock. */
        s->rwd = value;
        break;

    case 0x018 ... 0x01B:
        /* CCCR, For details about setting and resetting of single bits see
            Software initialization. */
        s->cccr = value;
        break;

    case 0x01C ... 0x01F:
        /* NBTP, FDCAN_NBTP */
        s->nbtp = value;
        break;

    case 0x020 ... 0x023:
        /* TSCC, FDCAN Timestamp Counter Configuration Register */
        s->tscc = value;
        break;

    case 0x024 ... 0x027:
        /* TSCV, FDCAN Timestamp Counter Value Register */
        s->tscv = value;
        break;

    case 0x028 ... 0x02B:
        /* TOCC, FDCAN Timeout Counter Configuration Register */
        s->tocc = value;
        break;

    case 0x02C ... 0x02F:
        /* TOCV, FDCAN Timeout Counter Value Register */
        s->tocv = value;
        break;

    case 0x040 ... 0x043:
        /* ECR, FDCAN Error Counter Register */
        s->ecr = value;
        break;

    case 0x044 ... 0x047:
        /* PSR, FDCAN Protocol Status Register */
        s->psr = value;
        break;

    case 0x048 ... 0x04B:
        /* TDCR, FDCAN Transmitter Delay Compensation Register */
        s->tdcr = value;
        break;

    case 0x050 ... 0x053:
        /* IR, The flags are set when one of the listed conditions is detected
            (edge-sensitive). The flags remain set until the Host clears them. A
            flag is cleared by writing a 1 to the corresponding bit position.
            Writing a 0 has no effect. A hard reset will clear the register. The
            configuration of IE controls whether an interrupt is generated. The
            configuration of ILS controls on which interrupt line an interrupt
            is signaled. */
        s->ir = value;
        break;

    case 0x054 ... 0x057:
        /* IE, The settings in the Interrupt Enable register determine which
            status changes in the Interrupt Register will be signaled on an
            interrupt line. */
        s->ie = value;
        break;

    case 0x058 ... 0x05B:
        /* ILS, The Interrupt Line Select register assigns an interrupt
            generated by a specific interrupt flag from the Interrupt Register
            to one of the two module interrupt lines. For interrupt generation
            the respective interrupt line has to be enabled via ILE[EINT0] and
            ILE[EINT1]. */
        s->ils = value;
        break;

    case 0x05C ... 0x05F:
        /* ILE, Each of the two interrupt lines to the CPU can be
            enabled/disabled separately by programming bits EINT0 and EINT1. */
        s->ile = value;
        break;

    case 0x080 ... 0x083:
        /* RXGFC, Global settings for Message ID filtering. The Global Filter
            Configuration controls the filter path for standard and extended
            messages as described in Figure706: Standard Message ID filter path
            and Figure707: Extended Message ID filter path. */
        s->rxgfc = value;
        break;

    case 0x084 ... 0x087:
        /* XIDAM, FDCAN Extended ID and Mask Register */
        s->xidam = value;
        break;

    case 0x088 ... 0x08B:
        /* HPMS, This register is updated every time a Message ID filter element
            configured to generate a priority event match. This can be used to
            monitor the status of incoming high priority messages and to enable
            fast access to these messages. */
        s->hpms = value;
        break;

    case 0x090 ... 0x093:
        /* RXF0S, FDCAN Rx FIFO 0 Status Register */
        s->rxf0s = value;
        break;

    case 0x094 ... 0x097:
        /* RXF0A, CAN Rx FIFO 0 Acknowledge Register */
        s->rxf0a = value;
        break;

    case 0x098 ... 0x09B:
        /* RXF1S, FDCAN Rx FIFO 1 Status Register */
        s->rxf1s = value;
        break;

    case 0x09C ... 0x09F:
        /* RXF1A, FDCAN Rx FIFO 1 Acknowledge Register */
        s->rxf1a = value;
        break;

    case 0x0C0 ... 0x0C3:
        /* TXBC, FDCAN Tx Buffer Configuration Register */
        s->txbc = value;
        break;

    case 0x0C4 ... 0x0C7:
        /* TXFQS, The Tx FIFO/Queue status is related to the pending Tx requests
            listed in register TXBRP. Therefore the effect of Add/Cancellation
            requests may be delayed due to a running Tx scan (TXBRP not yet
            updated). */
        s->txfqs = value;
        break;

    case 0x0C8 ... 0x0CB:
        /* TXBRP, FDCAN Tx Buffer Request Pending Register */
        s->txbrp = value;
        break;

    case 0x0CC ... 0x0CF:
        /* TXBAR, FDCAN Tx Buffer Add Request Register */
        s->txbar = value;
        break;

    case 0x0D0 ... 0x0D3:
        /* TXBCR, FDCAN Tx Buffer Cancellation Request Register */
        s->txbcr = value;
        break;

    case 0x0D4 ... 0x0D7:
        /* TXBTO, FDCAN Tx Buffer Transmission Occurred Register */
        s->txbto = value;
        break;

    case 0x0D8 ... 0x0DB:
        /* TXBCF, FDCAN Tx Buffer Cancellation Finished Register */
        s->txbcf = value;
        break;

    case 0x0DC ... 0x0DF:
        /* TXBTIE, FDCAN Tx Buffer Transmission Interrupt Enable Register */
        s->txbtie = value;
        break;

    case 0x0E0 ... 0x0E3:
        /* TXBCIE, FDCAN Tx Buffer Cancellation Finished Interrupt Enable
            Register */
        s->txbcie = value;
        break;

    case 0x0E4 ... 0x0E7:
        /* TXEFS, FDCAN Tx Event FIFO Status Register */
        s->txefs = value;
        break;

    case 0x0E8 ... 0x0EB:
        /* TXEFA, FDCAN Tx Event FIFO Acknowledge Register */
        s->txefa = value;
        break;

    case 0x100 ... 0x103:
        /* CKDIV, FDCAN CFG clock divider register */
        s->ckdiv = value;
        break;

    default:
        printf("%s: unimplemented write to 0x%" HWADDR_PRIx ", size %d, "
               "value 0x%" PRIx64 "\n", __func__, offset, size, value);
        break;
    }
}

static const MemoryRegionOps stm32g4_fdcan_mmio_ops = {
    .read = stm32g4_fdcan_mmio_read,
    .write = stm32g4_fdcan_mmio_write,
    .impl = {
        .max_access_size = 4
    }
};

static void stm32g4_fdcan_instance_init(Object *obj)
{
    STM32G4FDCANState *s = STM32G4_FDCAN(obj);

    memory_region_init_io(&s->mmio, obj, &stm32g4_fdcan_mmio_ops, s,
                          STM32G4_FDCAN_MMIO, STM32G4_FDCAN_MMIO_SIZE);
    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &s->mmio);
}

static void stm32g4_fdcan_realize(DeviceState *dev, Error **errp)
{
    __attribute__((unused)) STM32G4FDCANState *s = STM32G4_FDCAN(dev);
}

static void stm32g4_fdcan_reset(DeviceState *dev)
{
    STM32G4FDCANState *s = STM32G4_FDCAN(dev);

    s->crel = 0x11111111;
    s->endn = 0x87654321;
    s->dbtp = 0x00000A33;
    s->test = 0x00000000;
    s->rwd = 0x00000000;
    s->cccr = 0x00000001;
    s->nbtp = 0x00000A33;
    s->tscc = 0x00000000;
    s->tscv = 0x00000000;
    s->tocc = 0xFFFF0000;
    s->tocv = 0x0000FFFF;
    s->ecr = 0x00000000;
    s->psr = 0x00000707;
    s->tdcr = 0x00000000;
    s->ir = 0x00000000;
    s->ie = 0x00000000;
    s->ils = 0x00000000;
    s->ile = 0x00000000;
    s->rxgfc = 0x00000000;
    s->xidam = 0x1FFFFFFF;
    s->hpms = 0x00000000;
    s->rxf0s = 0x00000000;
    s->rxf0a = 0x00000000;
    s->rxf1s = 0x00000000;
    s->rxf1a = 0x00000000;
    s->txbc = 0x00000000;
    s->txfqs = 0x00000000;
    s->txbrp = 0x00000000;
    s->txbar = 0x00000000;
    s->txbcr = 0x00000000;
    s->txbto = 0x00000000;
    s->txbcf = 0x00000000;
    s->txbtie = 0x00000000;
    s->txbcie = 0x00000000;
    s->txefs = 0x00000000;
    s->txefa = 0x00000000;
    s->ckdiv = 0x00000000;
}

static void stm32g4_fdcan_unrealize(DeviceState *dev, Error **errp)
{
    __attribute__((unused)) STM32G4FDCANState *s = STM32G4_FDCAN(dev);
}

static Property stm32g4_fdcan_properties[] = {
    DEFINE_PROP_END_OF_LIST()
};

static const VMStateDescription vmstate_stm32g4_fdcan = {
    .name = "stm32g4_fdcan",
    .version_id = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32(crel, STM32G4FDCANState),
        VMSTATE_UINT32(endn, STM32G4FDCANState),
        VMSTATE_UINT32(dbtp, STM32G4FDCANState),
        VMSTATE_UINT32(test, STM32G4FDCANState),
        VMSTATE_UINT32(rwd, STM32G4FDCANState),
        VMSTATE_UINT32(cccr, STM32G4FDCANState),
        VMSTATE_UINT32(nbtp, STM32G4FDCANState),
        VMSTATE_UINT32(tscc, STM32G4FDCANState),
        VMSTATE_UINT32(tscv, STM32G4FDCANState),
        VMSTATE_UINT32(tocc, STM32G4FDCANState),
        VMSTATE_UINT32(tocv, STM32G4FDCANState),
        VMSTATE_UINT32(ecr, STM32G4FDCANState),
        VMSTATE_UINT32(psr, STM32G4FDCANState),
        VMSTATE_UINT32(tdcr, STM32G4FDCANState),
        VMSTATE_UINT32(ir, STM32G4FDCANState),
        VMSTATE_UINT32(ie, STM32G4FDCANState),
        VMSTATE_UINT32(ils, STM32G4FDCANState),
        VMSTATE_UINT32(ile, STM32G4FDCANState),
        VMSTATE_UINT32(rxgfc, STM32G4FDCANState),
        VMSTATE_UINT32(xidam, STM32G4FDCANState),
        VMSTATE_UINT32(hpms, STM32G4FDCANState),
        VMSTATE_UINT32(rxf0s, STM32G4FDCANState),
        VMSTATE_UINT32(rxf0a, STM32G4FDCANState),
        VMSTATE_UINT32(rxf1s, STM32G4FDCANState),
        VMSTATE_UINT32(rxf1a, STM32G4FDCANState),
        VMSTATE_UINT32(txbc, STM32G4FDCANState),
        VMSTATE_UINT32(txfqs, STM32G4FDCANState),
        VMSTATE_UINT32(txbrp, STM32G4FDCANState),
        VMSTATE_UINT32(txbar, STM32G4FDCANState),
        VMSTATE_UINT32(txbcr, STM32G4FDCANState),
        VMSTATE_UINT32(txbto, STM32G4FDCANState),
        VMSTATE_UINT32(txbcf, STM32G4FDCANState),
        VMSTATE_UINT32(txbtie, STM32G4FDCANState),
        VMSTATE_UINT32(txbcie, STM32G4FDCANState),
        VMSTATE_UINT32(txefs, STM32G4FDCANState),
        VMSTATE_UINT32(txefa, STM32G4FDCANState),
        VMSTATE_UINT32(ckdiv, STM32G4FDCANState),
        VMSTATE_END_OF_LIST()
    }
};

static void stm32g4_fdcan_class_init(ObjectClass *oc, void *opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);

    dc->realize   = stm32g4_fdcan_realize;
    dc->reset     = stm32g4_fdcan_reset;
    dc->unrealize = stm32g4_fdcan_unrealize;
    dc->vmsd      = &vmstate_stm32g4_fdcan;
    device_class_set_props(dc, stm32g4_fdcan_properties);
}

static TypeInfo stm32g4_fdcan_info = {
    .name          = TYPE_STM32G4_FDCAN,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(STM32G4FDCANState),
    .instance_init = stm32g4_fdcan_instance_init,
    .class_init    = stm32g4_fdcan_class_init
};

static void stm32g4_fdcan_register_types(void)
{
    type_register_static(&stm32g4_fdcan_info);
}

type_init(stm32g4_fdcan_register_types)
